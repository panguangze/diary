# Love Diary - Copilot Instructions

This document provides actionable context and guidelines for GitHub Copilot (web coding agent and Android Studio) when working on the Love Diary repository.

## ‚ö†Ô∏è Required Verification Commands

**ALWAYS run these commands before completing any changes:**

```bash
# Minimum required (MUST run before finalizing):
./gradlew assembleDebug    # Build debug APK - catches compilation errors
./gradlew test             # Run unit tests - validates logic

# Also run when relevant:
./gradlew assembleRelease  # When touching release configs or ProGuard rules
./gradlew connectedAndroidTest  # When adding/modifying instrumented tests (requires emulator/device)
```

**Note:** This project has no fixed lint/format task configured. Focus on build and test verification.

---

## Project Overview

Love Diary is an Android diary application designed for long-distance relationships, allowing couples to track their daily moods, milestones, and memories. The app is built with modern Android development practices.

## Technology Stack

- **Language**: Kotlin 2.0.21 (99.4% of codebase)
- **UI Framework**: Jetpack Compose with Material 3
- **Architecture**: MVVM (Model-View-ViewModel)
- **Dependency Injection**: Hilt/Dagger 2.52
- **Database**: Room 2.6.1 with SQLite (**currently at version 9**)
- **Async Operations**: Kotlin Coroutines & Flow
- **Navigation**: Jetpack Navigation Compose
- **Image Loading**: Coil 2.5.0
- **Charts**: Vico Charts 1.12.0
- **Min SDK**: 26 (Android 8.0 Oreo)
- **Target SDK**: 34
- **Compile SDK**: 34

## Project Structure

```
app/src/main/java/com/love/diary/
‚îú‚îÄ‚îÄ data/
‚îÇ   ‚îú‚îÄ‚îÄ backup/          # Backup/restore managers
‚îÇ   ‚îú‚îÄ‚îÄ database/        # Room database, DAOs, entities
‚îÇ   ‚îú‚îÄ‚îÄ model/           # Data models and enums
‚îÇ   ‚îî‚îÄ‚îÄ repository/      # Repository layer
‚îú‚îÄ‚îÄ di/                  # Dependency injection modules (Hilt)
‚îú‚îÄ‚îÄ presentation/
‚îÇ   ‚îú‚îÄ‚îÄ components/      # Reusable UI components
‚îÇ   ‚îú‚îÄ‚îÄ screens/         # Screen composables
‚îÇ   ‚îî‚îÄ‚îÄ viewmodel/       # ViewModels
‚îú‚îÄ‚îÄ ui/
‚îÇ   ‚îî‚îÄ‚îÄ theme/           # Theme configuration
‚îî‚îÄ‚îÄ util/                # Utility classes
    ‚îú‚îÄ‚îÄ NotificationHelper.kt  # Local notifications and reminders
    ‚îî‚îÄ‚îÄ ShareHelper.kt         # Content sharing (text and images)
```

---

## Architecture Rules (MUST FOLLOW)

### üèóÔ∏è MVVM Layer Separation
**Rule**: NEVER violate layer boundaries
- ‚úÖ **View (Compose)** ‚Üí calls ViewModel methods, observes StateFlow
- ‚úÖ **ViewModel** ‚Üí calls Repository, exposes StateFlow<UiState>
- ‚úÖ **Repository** ‚Üí calls DAOs, handles data logic
- ‚úÖ **DAO/Room** ‚Üí raw database operations only
- ‚ùå **NEVER**: Direct DAO access from ViewModel or View
- ‚ùå **NEVER**: UI logic in Repository or ViewModel

### üì± Compose UI Rules
1. **Pass ViewModels only to screen-level composables**, not to reusable components
2. **Extract reusable UI to `presentation/components/`** - keep screens focused
3. **Use `remember` and `rememberSaveable`** appropriately for state
4. **Material 3 components only** - no Material 2 imports
5. **Follow unidirectional data flow**: `UiState` down, `Events` up

### üîÑ State Management Rules
1. **ViewModels MUST use `StateFlow<UiState>`** for observable state
2. **Create a data class `UiState`** for each screen (e.g., `HomeUiState`, `HistoryUiState`)
3. **In Compose, use `.collectAsState()`** to observe flows
4. **Never expose mutable state** - only `StateFlow` (immutable view)

### üíæ Repository Rules
1. **Use `Flow<T>` for reactive queries** that auto-update UI
2. **Use `suspend fun` for one-shot operations** (insert, update, delete)
3. **Wrap all DAO calls in try-catch** and log errors
4. **Repositories are `@Singleton`** - inject via Hilt

### üíâ Dependency Injection Rules
1. **Use `@HiltViewModel`** for all ViewModels
2. **Use `@Singleton`** for Repositories
3. **Create modules in `di/` package** for complex dependencies
4. **Never manually instantiate** - always inject

---

## Room/Database Migration Requirements

### Current Database State
- **Version**: 9 (as of `LoveDatabase.kt`)
- **Schema export location**: `app/schemas/` (auto-generated by KSP on build)
- **Migration helper**: `MigrationHelper.kt` contains all migrations

### Key Tables (Version 9)
- `daily_mood` - Daily mood tracking
- `unified_check_in` - **Primary** unified check-in system (preferred for new features)
- `habit` - **Legacy** habit system (being phased out, maintain compatibility)
- `event` - Event timeline entries
- `app_config` - App configuration storage

### MANDATORY Steps When Modifying Database Schema

**üö® NEVER skip schema migrations or you will break user data!**

1. **Increment version** in `@Database(version = X)` in `LoveDatabase.kt`
2. **Add migration** to `MigrationHelper.kt`:
   ```kotlin
   val MIGRATION_X_Y = object : Migration(X, Y) {
       override fun migrate(database: SupportSQLiteDatabase) {
           // SQL migration statements here
       }
   }
   ```
3. **Register migration** in `LoveDatabase.getInstance()` via `.addMigrations(...)`
4. **Build project** to auto-export schema: `./gradlew assembleDebug`
   - Schema JSON will be generated in `app/schemas/com.love.diary.LoveDatabase/X.json`
5. **Verify migration** works on existing database (test upgrade path)
6. **Commit schema JSON** to repository alongside code changes

### Room Best Practices
- **Use Type Converters** (see `Converters.kt`) for complex types (List, LocalDate, etc.)
- **Add indexes** for frequently queried columns: `@Entity(indices = [Index("column_name")])`
- **Use `@Query` with Flow<T>** for reactive queries that need live updates
- **Use `@Insert`, `@Update`, `@Delete`** for simple CRUD (Room generates code)
- **Test migrations** with Room's migration testing utilities

---

## PR Hygiene Checklist (For GitHub Web Copilot Agent)

Before marking a PR complete, verify:

### ‚úÖ Code Quality
- [ ] Changes compile: `./gradlew assembleDebug` passes
- [ ] Tests pass: `./gradlew test` passes
- [ ] No new warnings introduced (check build output)
- [ ] Code follows existing patterns (MVVM, naming conventions)
- [ ] No hardcoded strings (use `strings.xml` for user-facing text)

### ‚úÖ Architecture Compliance
- [ ] MVVM layers respected (no cross-layer violations)
- [ ] ViewModels use StateFlow for state management
- [ ] Repository pattern used for data access (no direct DAO calls from VM)
- [ ] Dependency injection used (no manual instantiation)

### ‚úÖ Database Changes (if applicable)
- [ ] Database version incremented
- [ ] Migration added to `MigrationHelper.kt` and registered
- [ ] Schema exported (JSON in `app/schemas/` committed)
- [ ] Migration tested (upgrade path validated)

### ‚úÖ Documentation
- [ ] PR title clearly describes the change
- [ ] PR description includes:
  - **What** changed (summary of modifications)
  - **Why** it changed (link to issue or rationale)
  - **How** to test (commands run, verification steps)
  - **UI changes** (screenshots if applicable)
  - **Database impact** (if schema changed, note version bump)
- [ ] Code comments added for non-obvious logic
- [ ] KDoc added for new public APIs

### ‚úÖ Testing Evidence
- [ ] List commands run (e.g., `./gradlew assembleDebug`, `./gradlew test`)
- [ ] Include build output summary (success/failure)
- [ ] For UI changes: attach before/after screenshots
- [ ] For database changes: confirm migration path works

---

## Building and Testing

### Build Commands
```bash
# Build debug APK (REQUIRED before completing changes)
./gradlew assembleDebug

# Build release APK (when touching ProGuard/release configs)
./gradlew assembleRelease

# Clean build (if encountering caching issues)
./gradlew clean assembleDebug
```

### Test Commands
```bash
# Run unit tests (REQUIRED before completing changes)
./gradlew test

# Run instrumented/UI tests (requires running emulator or connected device)
./gradlew connectedAndroidTest

# Run specific test class
./gradlew test --tests "com.love.diary.YourTestClass"
```

---

## Code Style and Conventions

### Kotlin Style (Enforce These)
- ‚úÖ Follow [Kotlin coding conventions](https://kotlinlang.org/docs/coding-conventions.html)
- ‚úÖ Use **meaningful variable names** (no single letters except loop indices)
- ‚úÖ Keep functions **small and focused** (single responsibility)
- ‚úÖ Prefer **immutability**: `val` over `var`
- ‚úÖ Use **data classes** for models (auto-generates equals/hashCode/copy)
- ‚úÖ Leverage **null safety** features (`?.`, `?:`, `!!` only when guaranteed non-null)
- ‚ùå No `!!` operator without clear null-safety guarantee

### Documentation Standards
- **KDoc comments** for all public APIs:
  ```kotlin
  /**
   * Brief description of what this does.
   * @param paramName Description of parameter
   * @return Description of return value
   */
  ```
- **Document Repository methods** with error handling details
- **Document ViewModel state classes** with property descriptions
- **Include usage examples** in utility classes

### Naming Conventions (MUST FOLLOW)
| Type | Pattern | Example |
|------|---------|---------|
| ViewModels | `*ViewModel` | `HomeViewModel`, `HistoryViewModel` |
| Repositories | `*Repository` | `AppRepository`, `CheckInRepository` |
| Screens | `*Screen` | `HomeScreen`, `HistoryScreen` |
| Composables | `PascalCase` | `MoodCard`, `StatisticsChart` |
| DAOs | `*Dao` | `MoodDao`, `CheckInDao` |
| Entities | Table/model name | `DailyMood`, `UnifiedCheckIn` |
| State classes | `*UiState` | `HomeUiState`, `SettingsUiState` |

### Compose Guidelines (MUST FOLLOW)
- ‚úÖ **Material 3 components only** (`androidx.compose.material3`)
- ‚úÖ **Prefer `@Composable` functions** over classes
- ‚úÖ **Extract reusable UI** to `presentation/components/`
- ‚úÖ **Use `remember`** for computed state within composition
- ‚úÖ **Use `rememberSaveable`** for state that survives configuration changes
- ‚úÖ **Follow unidirectional data flow**: state flows down, events flow up
- ‚úÖ **Pass ViewModels only to screen-level composables**, not to reusable components
- ‚ùå **No side effects in composables** - use `LaunchedEffect` or `DisposableEffect`

---

## Architecture Patterns

### MVVM Implementation
- **View**: Jetpack Compose UI (no business logic)
- **ViewModel**: Business logic, state management with StateFlow
- **Model**: Data layer (Repository + Room)

**Responsibilities**:
- **View**: Display UI, handle user input, observe state
- **ViewModel**: Process events, update state, coordinate data operations
- **Repository**: Abstract data sources, handle caching, error handling
- **DAO**: Direct database queries only

### State Management
- ‚úÖ **Use `StateFlow<UiState>` in ViewModels** for observable state
- ‚úÖ **Create UI state data classes** for each screen:
  ```kotlin
  data class HomeUiState(
      val isLoading: Boolean = false,
      val moods: List<Mood> = emptyList(),
      val error: String? = null
  )
  ```
- ‚úÖ **Use `collectAsState()` in Compose** to observe flows:
  ```kotlin
  val uiState by viewModel.uiState.collectAsState()
  ```
- ‚ùå **Never expose mutable state** directly (no `MutableStateFlow` in public API)

### Repository Pattern
- ‚úÖ **Repositories abstract data sources** (Room, network, SharedPreferences)
- ‚úÖ **Use `Flow<T>` for reactive queries** (auto-updates UI on data change)
- ‚úÖ **Use `suspend fun` for one-shot operations** (insert, update, delete)
- ‚úÖ **Handle errors with try-catch** and log appropriately
- ‚úÖ **Return `Result<T>` for operations** that can fail:
  ```kotlin
  suspend fun saveMood(mood: Mood): Result<Unit> = try {
      dao.insert(mood)
      Result.success(Unit)
  } catch (e: Exception) {
      Log.e("Repository", "Failed to save mood", e)
      Result.failure(e)
  }
  ```

### Dependency Injection
- ‚úÖ **Use Hilt** for all dependency injection
- ‚úÖ **Module classes in `di/` package**
- ‚úÖ **`@HiltViewModel` for ViewModels**
- ‚úÖ **`@Singleton` for Repositories**
- ‚ùå **Never manually instantiate** dependencies that can be injected

---

## Database

### Room Configuration
- **Database version**: 9 (see `LoveDatabase.kt`)
- **Schema location**: `app/schemas/` (configured via KSP in `app/build.gradle.kts`)
- **Export enabled**: `exportSchema = true` in `@Database` annotation
- **Type Converters**: See `Converters.kt` for handling complex types
- **Migrations**: See `MigrationHelper.kt` for all version migrations

### Database Entities (Version 9)
Key tables:
- **`daily_mood`** - Daily mood tracking (6 emotion types)
- **`unified_check_in`** - **PRIMARY** unified check-in system (use for new features)
- **`habit`** - **LEGACY** habit system (being phased out, maintain backward compatibility)
- **`event`** - Event timeline entries
- **`app_config`** - Application configuration storage

**Migration Strategy**: The project is transitioning from legacy `Habit` to `UnifiedCheckIn`:
- ‚úÖ **Use `UnifiedCheckIn`** for all new check-in features
- ‚ö†Ô∏è **Maintain `Habit`** for backward compatibility (do not break existing data)
- üìñ See `docs/REFACTORING_PLAN.md` for complete migration roadmap

### Query Best Practices
- ‚úÖ **Use `Flow<T>` for reactive queries** that auto-update UI:
  ```kotlin
  @Query("SELECT * FROM daily_mood ORDER BY date DESC")
  fun getAllMoods(): Flow<List<DailyMood>>
  ```
- ‚úÖ **Use `suspend fun` for one-time queries**:
  ```kotlin
  @Query("SELECT * FROM daily_mood WHERE id = :id")
  suspend fun getMoodById(id: Long): DailyMood?
  ```
- ‚úÖ **Add indexes** for frequently queried columns:
  ```kotlin
  @Entity(indices = [Index(value = ["date"], unique = true)])
  ```
- ‚úÖ **Follow Room best practices** for complex queries (use relationships, avoid N+1)

---

---

## Testing Strategy

### Unit Tests
- ‚úÖ **Test ViewModels** with `kotlinx-coroutines-test`:
  ```kotlin
  @Test
  fun `test ViewModel state update`() = runTest {
      // Given/When/Then
  }
  ```
- ‚úÖ **Test Repositories** with test doubles (fake DAOs)
- ‚úÖ **Mock dependencies** using Mockito or MockK
- ‚úÖ **Use `TestCoroutineDispatcher`** for testing coroutines

### Test Location
- **Unit tests**: `app/src/test/java/`
- **Instrumented tests**: `app/src/androidTest/java/`

### Testing Guidelines (MUST DO)
- ‚úÖ **Write tests for business logic** (especially ViewModels)
- ‚úÖ **Test error handling paths** (network failures, database errors)
- ‚úÖ **Verify state changes in ViewModels** (initial ‚Üí loading ‚Üí success/error)
- ‚úÖ **Test database operations** with Room testing utilities
- ‚úÖ **Run tests before completing changes**: `./gradlew test`

---

---

## Key Features to Maintain (DO NOT BREAK)

### Core Features
1. ‚úÖ Daily mood tracking with 6 emotion types
2. ‚úÖ Relationship day counter
3. ‚úÖ Anniversary reminders
4. ‚úÖ Habit tracking (legacy + unified check-in)
5. ‚úÖ Statistics and trends visualization
6. ‚úÖ Data backup/restore functionality

### Privacy & Security (CRITICAL)
- ‚úÖ All data stored **locally** by default (no cloud sync)
- ‚úÖ No analytics or tracking
- ‚úÖ Secure file sharing with `FileProvider`
- ‚úÖ Support for encrypted database (ready for implementation)
- ‚ùå **NEVER** send user data to external services without explicit consent

### Accessibility (REQUIRED)
- ‚úÖ Content descriptions for all interactive elements
- ‚úÖ Screen reader support (`contentDescription` on all buttons/images)
- ‚úÖ High contrast color schemes (Material 3 theming)
- ‚úÖ Proper touch target sizes (minimum 48dp)

---

---

## Common Tasks (Step-by-Step Guides)

### Adding a New Screen
1. **Create screen composable** in `presentation/screens/[feature]/[Feature]Screen.kt`
2. **Create ViewModel** in `presentation/viewmodel/[Feature]ViewModel.kt`:
   - Use `@HiltViewModel`
   - Create `[Feature]UiState` data class
   - Expose `StateFlow<UiState>`
3. **Add navigation route** in navigation configuration (usually `MainActivity.kt` or navigation graph)
4. **Update `NavHost`** with new destination and route
5. **Add Repository methods** if needed for data operations
6. **Write tests** for ViewModel logic
7. **Build and test**: `./gradlew assembleDebug && ./gradlew test`

### Adding a New Database Entity
1. **Create entity class** in `data/database/entities/[Entity].kt`:
   ```kotlin
   @Entity(tableName = "table_name")
   data class MyEntity(
       @PrimaryKey(autoGenerate = true) val id: Long = 0,
       // fields...
   )
   ```
2. **Create DAO interface** in `data/database/dao/[Entity]Dao.kt`
3. **Update `LoveDatabase.kt`**:
   - Add entity to `@Database(entities = [...])`
   - **Increment `version`** (e.g., 9 ‚Üí 10)
   - Add abstract DAO getter
4. **Create migration** in `MigrationHelper.kt`:
   ```kotlin
   val MIGRATION_9_10 = object : Migration(9, 10) {
       override fun migrate(database: SupportSQLiteDatabase) {
           database.execSQL("CREATE TABLE table_name (...)")
       }
   }
   ```
5. **Register migration** in `LoveDatabase.getInstance()`: `.addMigrations(MIGRATION_9_10)`
6. **Build to export schema**: `./gradlew assembleDebug`
   - Schema JSON auto-generated in `app/schemas/com.love.diary.LoveDatabase/10.json`
7. **Commit schema JSON** with code changes
8. **Test migration** (verify upgrade path works)
9. **Update Repository** to use new DAO

### Adding a New Dependency
1. **Add to `app/build.gradle.kts`** dependencies block:
   ```kotlin
   implementation("group:artifact:version")
   ```
2. **Sync Gradle**: `./gradlew build --refresh-dependencies` or sync in IDE
3. **If Hilt module needed**, create in `di/[Module]Module.kt`
4. **Build and test**: `./gradlew assembleDebug && ./gradlew test`

---

---

## Important Notes

### Migration Strategy (UnifiedCheckIn vs Legacy Habit)
The project is migrating from a legacy `Habit` system to a unified `UnifiedCheckIn` system:
- ‚úÖ **`UnifiedCheckIn`**: Primary data store - **use this for new features**
- ‚ö†Ô∏è **Legacy `Habit`**: Maintained for backward compatibility - **do not break**
- üîÑ **Bridge pattern** during transition - data sync between systems
- üìñ See `docs/REFACTORING_PLAN.md` for complete migration strategy and roadmap

### Documentation
Comprehensive documentation available in `docs/`:
- **`ARCHITECTURE.md`** - Complete architecture guide and design decisions
- **`DATABASE_SCHEMA.md`** - Database design, schema details, and relationships
- **`REFACTORING_PLAN.md`** - Refactoring strategy and migration roadmap
- **`SUMMARY.md`** - Project summary and overview

**Read these before making architectural changes!**

---

## Git Workflow

### Branching Strategy
- ‚úÖ Use **feature branches** for new work: `feature/description` or `fix/description`
- ‚úÖ Write **semantic commit messages**: `feat:`, `fix:`, `docs:`, `refactor:`, etc.
- ‚úÖ Keep **pull requests focused and small** (single concern per PR)
- ‚úÖ Maintain **linear history** where possible (rebase instead of merge when appropriate)

### Commit Message Format
```
<type>: <short summary>

<optional detailed description>
```

Types: `feat`, `fix`, `docs`, `style`, `refactor`, `test`, `chore`

Example:
```
feat: Add mood statistics chart to home screen

- Integrated Vico Charts library
- Created MoodStatisticsCard composable
- Added ViewModel logic for 7-day mood aggregation
```

---

## Additional Resources

### Official Documentation
- **Material Design 3**: https://m3.material.io/
- **Jetpack Compose**: https://developer.android.com/jetpack/compose
- **Kotlin Coroutines**: https://kotlinlang.org/docs/coroutines-overview.html
- **Room Database**: https://developer.android.com/training/data-storage/room
- **Hilt Dependency Injection**: https://developer.android.com/training/dependency-injection/hilt-android

### Quick Reference
- **Kotlin Coding Conventions**: https://kotlinlang.org/docs/coding-conventions.html
- **Compose Guidelines**: https://developer.android.com/jetpack/compose/mental-model
- **MVVM Architecture**: https://developer.android.com/topic/architecture

---

## Summary for GitHub Web Copilot Agent

**When working on this repository:**

1. ‚ö†Ô∏è **ALWAYS run before completing**: `./gradlew assembleDebug && ./gradlew test`
2. üèóÔ∏è **Follow MVVM strictly**: View ‚Üí ViewModel ‚Üí Repository ‚Üí DAO
3. üíæ **Database changes = Migration required** (increment version, add migration, export schema)
4. ‚úÖ **Use PR checklist** above to ensure quality and completeness
5. üìñ **Read `docs/` for architectural context** before major changes
6. üîÑ **Prefer `UnifiedCheckIn`** over legacy `Habit` for new features
7. üé® **Material 3 + Compose** for all UI (no Material 2)
8. üíâ **Hilt for DI** (never manual instantiation)
9. üì± **Test on real device/emulator** for UI changes (take screenshots for PR)
10. üîí **Privacy first**: No external data sharing, local storage only

**This file is your source of truth. Follow it rigorously for consistent, high-quality contributions.**
